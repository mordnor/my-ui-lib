// tools/token-engine.mjs
import StyleDictionary from 'style-dictionary'
import path from 'path'
import fs from 'fs'

/**
 * 🧠 DS Token Builder — génère CSS, JS, TS et JSON pour chaque thème
 * Architecture 3 couches: base → semantic → theme
 * Préfixe DS : toutes les variables utilisent --ds-*
 */

/**
 * 🎨 Custom format: TypeScript typed constants
 */
const typescriptFormat = {
  name: 'typescript/tokens',
  format: ({ dictionary }) => {
    const buildTokenTree = (tokens, prefix = '') => {
      const result = {}

      tokens.forEach(token => {
        const path = token.path.slice(1) // Remove 'ds' prefix
        let current = result

        for (let i = 0; i < path.length - 1; i++) {
          const key = path[i]
          if (!current[key]) {
            current[key] = {}
          }
          current = current[key]
        }

        const lastKey = path[path.length - 1]
        current[lastKey] = token.value
      })

      return result
    }

    const generateTypeScript = (obj, indent = 0) => {
      const spacing = '  '.repeat(indent)
      let ts = '{\n'

      for (const [key, value] of Object.entries(obj)) {
        // Make key safe: quote if starts with number, has dashes, or special chars
        const needsQuotes = /^[0-9]/.test(key) || /[-\s]/.test(key)
        const safeKey = needsQuotes ? `'${key}'` : key

        if (
          typeof value === 'object' &&
          value !== null &&
          !Array.isArray(value)
        ) {
          ts += `${spacing}  ${safeKey}: ${generateTypeScript(value, indent + 1)},\n`
        } else {
          // Escape single quotes in string values
          const escapedValue = typeof value === 'string'
            ? value.replace(/'/g, "\\'")
            : value
          const stringValue = typeof value === 'string' ? `'${escapedValue}'` : value
          ts += `${spacing}  ${safeKey}: ${stringValue},\n`
        }
      }

      ts += `${spacing}}`
      return ts
    }

    const tokenTree = buildTokenTree(dictionary.allTokens)

    return `/**
 * 🎨 Design System Tokens
 * Auto-generated by Style Dictionary
 * DO NOT EDIT MANUALLY
 */

export const tokens = ${generateTypeScript(tokenTree)} as const

export type Tokens = typeof tokens

export default tokens
`
  }
}

/**
 * 🎨 Custom format: JavaScript object for Tailwind
 */
const tailwindFormat = {
  name: 'javascript/tailwind',
  format: ({ dictionary }) => {
    const buildTokenTree = (tokens) => {
      const result = {}

      tokens.forEach(token => {
        let current = result

        for (let i = 0; i < token.path.length - 1; i++) {
          const key = token.path[i]
          if (!current[key]) {
            current[key] = {}
          }
          current = current[key]
        }

        const lastKey = token.path[token.path.length - 1]
        current[lastKey] = token.value
      })

      return result
    }

    const tokenTree = buildTokenTree(dictionary.allTokens)

    return `/**
 * 🎨 Design System Tokens for Tailwind
 * Auto-generated by Style Dictionary
 * DO NOT EDIT MANUALLY
 */

export default ${JSON.stringify(tokenTree, null, 2)}
`
  }
}

export async function buildTokens({ tokensDir, outputDir, themes = [] }) {
  if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true })

  const cssOut = path.join(outputDir, 'css')
  const tsOut = path.join(outputDir, 'ts')

  if (!fs.existsSync(cssOut)) fs.mkdirSync(cssOut, { recursive: true })
  if (!fs.existsSync(tsOut)) fs.mkdirSync(tsOut, { recursive: true })

  console.log(`\n🧩 Building tokens from → ${tokensDir}`)
  console.log(`📦 3-layer architecture: primitives → semantic → theme\n`)

  // Register custom formats
  StyleDictionary.registerFormat(typescriptFormat)
  StyleDictionary.registerFormat(tailwindFormat)

  // 🧱 Chemin vers les tokens primitifs et sémantiques
  const baseTokens = path.join(tokensDir, 'primitives/**/*.json')
  const semanticTokens = path.join(tokensDir, 'semantic/**/*.json')

  for (const theme of themes) {
    const themeTokens = path.join(tokensDir, 'themes', `${theme}.json`)

    console.log(`🎨 Building theme: "${theme}"`)
    console.log(`  📂 Primitives: ${baseTokens}`)
    console.log(`  📂 Semantic: ${semanticTokens}`)
    console.log(`  📂 Theme: ${themeTokens}`)

    // Sources dans l'ordre: base → semantic → theme
    const sources = [baseTokens, semanticTokens]

    // Ajouter le theme s'il existe
    if (fs.existsSync(themeTokens)) {
      sources.push(themeTokens)
    } else {
      console.log(`  ⚠️  Theme file not found, using semantic defaults`)
    }

    /* 🧱 Création instance SD pour Style Dictionary 5.x */
    const config = {
      log: { verbosity: 'default' },
      source: sources,
      platforms: {
        /**
         * 🎨 CSS Variables — appliquées sur [data-theme="x"]
         */
        css: {
          transformGroup: 'css',
          buildPath: path.join(cssOut, '/'),
          files: [
            {
              destination: `${theme}.css`,
              format: 'css/variables',
              options: {
                showFileHeader: false,
                outputReferences: true,
                selector: `[data-theme='${theme}']`
              }
            }
          ]
        },

        /**
         * 💾 JS (ESM) — tokens utilisés par Tailwind
         */
        js: {
          transformGroup: 'js',
          buildPath: outputDir + '/',
          files: [
            {
              destination: 'tailwind.tokens.js',
              format: 'javascript/tailwind',
              options: {
                showFileHeader: false
              }
            }
          ]
        },

        /**
         * 📘 TypeScript — typed constants for React
         */
        ts: {
          transformGroup: 'js',
          buildPath: tsOut + '/',
          files: [
            {
              destination: `${theme}.ts`,
              format: 'typescript/tokens'
            }
          ]
        },

        /**
         * 🧰 JSON brut (debug ou import direct)
         */
        json: {
          transformGroup: 'js',
          buildPath: outputDir + '/',
          files: [
            {
              destination: `${theme}.json`,
              format: 'json/nested',
              options: { showFileHeader: false }
            }
          ]
        }
      }
    }

    // Style Dictionary 5.x API
    const SD = new StyleDictionary(config)
    await SD.buildAllPlatforms()

    console.log(`  ✅ Theme "${theme}" built successfully\n`)
  }

  // 🧩 Combine les CSS thèmes en un seul fichier
  const combinedCss = themes
    .map(theme => fs.readFileSync(path.join(cssOut, `${theme}.css`), 'utf8'))
    .join('\n\n')

  fs.writeFileSync(path.join(cssOut, 'themes.css'), combinedCss)
  console.log(`🎨 Combined CSS → ${path.join(cssOut, 'themes.css')}`)

  // 📘 Crée un fichier TypeScript d'index
  const tsIndexContent = themes
    .map(theme => {
      // Convert theme name to camelCase for valid JS identifier
      const camelCaseName = theme.replace(/-([a-z])/g, (g) => g[1].toUpperCase())
      return `export { tokens as ${camelCaseName}Tokens } from './${theme}'`
    })
    .join('\n') + '\n'

  fs.writeFileSync(path.join(tsOut, 'index.ts'), tsIndexContent)
  console.log(`📘 TypeScript index → ${path.join(tsOut, 'index.ts')}`)

  console.log(`\n✅ Token generation complete!\n`)
}
